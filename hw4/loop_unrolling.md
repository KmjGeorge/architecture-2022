# 循环展开
## 1 程序结构
整个程序的描述如下：
- 输入：一段（含有循环的）汇编代码
- 输出：经过循环展开和指令重排后的汇编代码
- 约束：输出代码应当能够直接被CPU执行，并且与输入代码等效

我们将整个程序划分为四个模块：
- 中间表示转化：将输入代码转化为中间表示，再将经过处理的中间表示转化为输出代码
- 循环展开：将代码中的循环展开若干次，展开的次数应当作为参数输入
- 虚拟寄存器：将代码中使用的虚拟寄存器号转化为物理寄存器号，适当加入与存储器交换的指令
- 指令重排：将指令重新排列，以消除指令之间的冲突，并**尽可能地**提高执行效率

程序结构图示：TODO

### 1.1 中间表示转化
#### 1.1.1 假设
为了简化问题，做如下的假设：
- 除了循环以外，输入代码中不含其他分支或跳转指令（比如if语句、goto语句、子函数调用）
- 不区分浮点运算和整数运算

#### 1.1.2 汇编代码形式
我们考虑的汇编代码中应当包含这些要素（参考PPT中的例程）：
- 标签：形如`label: [instruction]`，其中`label`是标签，`[instruction]`是某条指令
- 功能型指令，**至少**包括以下类型：
    - 加载：形如`load reg1, offset(reg2)`，其中`reg`是寄存器，`offset`是某个整数
    - 存储：形如`store reg1, offset(reg2)`，其中`reg`是寄存器，`offset`是某个整数
    - 加法：形如`add reg1, reg2, reg3`，其中`reg1`、`reg2`、`reg3`是寄存器
    - 加立即数：形如`addi reg1, reg2, imm`，其中`reg1`、`reg2`是寄存器，`imm`是某个整数
    - 空指令：形如`nop`
- 条件跳转指令，**至少**包括以下类型：
    - 不相等时跳转：形如`bne reg1, reg2, label`，其中`reg1`、`reg2`是寄存器，`label`是标签

#### 1.1.3 中间表示形式
中间表示的形式：
- 一个程序是一个列表，其中每一项或者是一个功能型指令、或者是一个循环
- 一个循环总是可以转化成while-do的形式，因此可以用一组条件判断和循环体表示：
    - 条件判断是一列功能型指令加上一个条件跳转指令
    - 循环体也是一个程序，它是一列功能型指令或循环（允许循环的嵌套）

形式化的表达是这样的：
```
program ::= [item, item, ..., item]
item ::= function | loop
loop ::= [condition, program]
condition ::= [func, func, ..., func, branch]
```

具体的实现在`ir/IR.py`中，可以阅读一下（TODO）

### 1.2 循环展开
#### 1.2.1 假设
为了简化问题，做如下的假设：
- 循环展开模块的输入是一个中间表示，因此其中的循环都是while-do的形式

#### 1.2.2 要求与注意事项
循环展开模块的输入是一个中间表示和展开的次数，作用是将其中的循环展开指定次数，输出也是一个中间表示

实现时注意边界条件，展开后的循环在跳出前的最后一次循环体可能有不一样的形式

实现者可以自行决定嵌套的循环如何展开：
- 展开最内层的循环
- 从内向外展开所有循环
- 将嵌套的循环展开成单层的循环

### 1.3 虚拟寄存器
#### 1.3.1 假设
为了简化问题，做如下的假设：
- 物理寄存器共32个
- 存储器中有一块专用区域作为寄存器的交换空间：
    - 交换空间是一块起始地址为0的连续存储空间
    - 交换空间足够大
- 循环展开模块输出的中间表示中，允许指令访问的寄存器号超过32

#### 1.3.2 要求
在循环展开模块中，通常需要使用更多的寄存器，我们允许指令访问的寄存器号可以是任意的，虚拟寄存器模块负责将这些虚拟寄存器号转化为物理寄存器号

当物理寄存器不够用时，需要将寄存器中的数据移到存储器中，在适当的时候调回（参考虚拟内存中的调页）

虚拟寄存器模块的输入和输出都是一个中间表示，输入中允许访问任意的虚拟寄存器号，而输出中仅允许访问有限的物理寄存器号

### 1.4 指令重排
#### 1.4.1 假设
与课上讲的假设一致，因为我们不区分浮点和整数运算，所以具体有以下假设：
- 5阶段流水线
- 分支延迟1周期，延迟槽中的指令无条件执行
- （其他假设由实现者自行补充在这里）

#### 1.4.2 要求与注意事项
指令重排模块的输入和输出都是一个中间表示

在正确的基础上，实现者可以自行决定优化到什么程度（可以先无脑插入nop）

## 2 分工
循环展开和虚拟寄存器两个模块的联系比较紧密，而且应该是工作量相对比较小的，所以由一个人做，其他每个模块各一个人：
- 中间表示转化：实现`ir/trans.py`中的`ir2code`和`code2ir`函数，所有代码放在`ir`目录下
- 循环展开、虚拟寄存器：实现`unroll/unroll.py`中的`unroll`函数和`vreg`函数，所有代码放在`unroll`目录下
- 指令重排：实现`reorder/reorder.py`中的`reorder`函数，所有代码放在`reorder`目录下
